From 21a10ba1c1123348cac185d8e349a49bec4d4c50 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Mon, 7 Dec 2020 19:15:30 +0000
Subject: [PATCH 1/2] Revert "api-macro: forbid description on incompatible
 schemas"

This reverts commit 273ce602427b2c74f160d0d0749bcdeddd36e23c.
---
 proxmox-api-macro/src/api/enums.rs  |  4 +--
 proxmox-api-macro/src/api/method.rs |  4 +--
 proxmox-api-macro/src/api/mod.rs    | 50 +++++++++++---------------
 proxmox-api-macro/src/lib.rs        | 56 ++---------------------------
 proxmox-api-macro/src/util.rs       | 53 ++-------------------------
 5 files changed, 28 insertions(+), 139 deletions(-)

diff --git a/proxmox-api-macro/src/api/enums.rs b/proxmox-api-macro/src/api/enums.rs
index 105d304..f6cc4db 100644
--- a/proxmox-api-macro/src/api/enums.rs
+++ b/proxmox-api-macro/src/api/enums.rs
@@ -7,7 +7,7 @@ use quote::quote_spanned;
 
 use super::Schema;
 use crate::serde;
-use crate::util::{self, FieldName, JSONObject, JSONValue, Maybe};
+use crate::util::{self, FieldName, JSONObject, JSONValue};
 
 /// Enums, provided they're simple enums, simply get an enum string schema attached to them.
 pub fn handle_enum(
@@ -30,7 +30,7 @@ pub fn handle_enum(
 
         if schema.description.is_none() {
             let (comment, span) = util::get_doc_comments(&enum_ty.attrs)?;
-            schema.description = Maybe::Derived(syn::LitStr::new(comment.trim(), span));
+            schema.description = Some(syn::LitStr::new(comment.trim(), span));
         }
 
         let mut ts = TokenStream::new();
diff --git a/proxmox-api-macro/src/api/method.rs b/proxmox-api-macro/src/api/method.rs
index 0d05cbb..8b8cfab 100644
--- a/proxmox-api-macro/src/api/method.rs
+++ b/proxmox-api-macro/src/api/method.rs
@@ -18,7 +18,7 @@ use syn::visit_mut::{self, VisitMut};
 use syn::Ident;
 
 use super::{Schema, SchemaItem};
-use crate::util::{self, FieldName, JSONObject, JSONValue, Maybe};
+use crate::util::{self, FieldName, JSONObject, JSONValue};
 
 /// Parse `input`, `returns` and `protected` attributes out of an function annotated
 /// with an `#[api]` attribute and produce a `const ApiMethod` named after the function.
@@ -29,7 +29,7 @@ pub fn handle_method(mut attribs: JSONObject, mut func: syn::ItemFn) -> Result<T
         Some(input) => input.into_object("input schema definition")?.try_into()?,
         None => Schema {
             span: Span::call_site(),
-            description: Maybe::None,
+            description: None,
             item: SchemaItem::Object(Default::default()),
             properties: Vec::new(),
         },
diff --git a/proxmox-api-macro/src/api/mod.rs b/proxmox-api-macro/src/api/mod.rs
index 81d9177..dc14ff8 100644
--- a/proxmox-api-macro/src/api/mod.rs
+++ b/proxmox-api-macro/src/api/mod.rs
@@ -17,7 +17,7 @@ use syn::parse::{Parse, ParseStream, Parser};
 use syn::spanned::Spanned;
 use syn::{ExprPath, Ident};
 
-use crate::util::{FieldName, JSONObject, JSONValue, Maybe};
+use crate::util::{FieldName, JSONObject, JSONValue};
 
 mod enums;
 mod method;
@@ -70,7 +70,7 @@ pub struct Schema {
     span: Span,
 
     /// Common in all schema entry types:
-    pub description: Maybe<syn::LitStr>,
+    pub description: Option<syn::LitStr>,
 
     /// The specific schema type (Object, String, ...)
     pub item: SchemaItem,
@@ -105,11 +105,10 @@ impl TryFrom<JSONObject> for Schema {
     type Error = syn::Error;
 
     fn try_from(mut obj: JSONObject) -> Result<Self, syn::Error> {
-        let description = Maybe::explicit(
-            obj.remove("description")
-                .map(|v| v.try_into())
-                .transpose()?,
-        );
+        let description = obj
+            .remove("description")
+            .map(|v| v.try_into())
+            .transpose()?;
 
         Ok(Self {
             span: obj.brace_token.span,
@@ -127,7 +126,7 @@ impl Schema {
     fn blank(span: Span) -> Self {
         Self {
             span,
-            description: Maybe::None,
+            description: None,
             item: SchemaItem::Inferred(span),
             properties: Vec::new(),
         }
@@ -136,7 +135,7 @@ impl Schema {
     fn empty_object(span: Span) -> Self {
         Self {
             span,
-            description: Maybe::None,
+            description: None,
             item: SchemaItem::Object(SchemaObject::new()),
             properties: Vec::new(),
         }
@@ -280,36 +279,35 @@ impl SchemaItem {
     fn to_inner_schema(
         &self,
         ts: &mut TokenStream,
-        description: Maybe<&syn::LitStr>,
+        description: Option<&syn::LitStr>,
         span: Span,
         properties: &[(Ident, syn::Expr)],
     ) -> Result<bool, Error> {
-        let check_description =
-            move || description.ok_or_else(|| format_err!(span, "missing description"));
+        let description = description.ok_or_else(|| format_err!(span, "missing description"));
 
         match self {
             SchemaItem::Null => {
-                let description = check_description()?;
+                let description = description?;
                 ts.extend(quote! { ::proxmox::api::schema::NullSchema::new(#description) });
             }
             SchemaItem::Boolean => {
-                let description = check_description()?;
+                let description = description?;
                 ts.extend(quote! { ::proxmox::api::schema::BooleanSchema::new(#description) });
             }
             SchemaItem::Integer => {
-                let description = check_description()?;
+                let description = description?;
                 ts.extend(quote! { ::proxmox::api::schema::IntegerSchema::new(#description) });
             }
             SchemaItem::Number => {
-                let description = check_description()?;
+                let description = description?;
                 ts.extend(quote! { ::proxmox::api::schema::NumberSchema::new(#description) });
             }
             SchemaItem::String => {
-                let description = check_description()?;
+                let description = description?;
                 ts.extend(quote! { ::proxmox::api::schema::StringSchema::new(#description) });
             }
             SchemaItem::Object(obj) => {
-                let description = check_description()?;
+                let description = description?;
                 let mut elems = TokenStream::new();
                 obj.to_schema_inner(&mut elems)?;
                 ts.extend(
@@ -317,7 +315,7 @@ impl SchemaItem {
                 );
             }
             SchemaItem::Array(array) => {
-                let description = check_description()?;
+                let description = description?;
                 let mut items = TokenStream::new();
                 array.to_schema(&mut items)?;
                 ts.extend(quote! {
@@ -326,23 +324,15 @@ impl SchemaItem {
             }
             SchemaItem::ExternType(path) => {
                 if !properties.is_empty() {
-                    error!(&properties[0].0 => "additional properties not allowed on external type");
+                    bail!(&properties[0].0 => "additional properties not allowed on external type");
                 }
-                if let Maybe::Explicit(description) = description {
-                    error!(description => "description not allowed on external type");
-                }
-
                 ts.extend(quote_spanned! { path.span() => #path::API_SCHEMA });
                 return Ok(true);
             }
             SchemaItem::ExternSchema(path) => {
                 if !properties.is_empty() {
-                    error!(&properties[0].0 => "additional properties not allowed on schema ref");
+                    bail!(&properties[0].0 => "additional properties not allowed on schema ref");
                 }
-                if let Maybe::Explicit(description) = description {
-                    error!(description => "description not allowed on external type");
-                }
-
                 ts.extend(quote_spanned! { path.span() => #path });
                 return Ok(true);
             }
@@ -364,7 +354,7 @@ impl SchemaItem {
     fn to_schema(
         &self,
         ts: &mut TokenStream,
-        description: Maybe<&syn::LitStr>,
+        description: Option<&syn::LitStr>,
         span: Span,
         properties: &[(Ident, syn::Expr)],
         typed: bool,
diff --git a/proxmox-api-macro/src/lib.rs b/proxmox-api-macro/src/lib.rs
index 2f543e7..eab8fcc 100644
--- a/proxmox-api-macro/src/lib.rs
+++ b/proxmox-api-macro/src/lib.rs
@@ -3,8 +3,6 @@
 extern crate proc_macro;
 extern crate proc_macro2;
 
-use std::cell::RefCell;
-
 use anyhow::Error;
 
 use proc_macro::TokenStream as TokenStream_1;
@@ -18,11 +16,6 @@ macro_rules! format_err {
     ($span:expr, $($msg:tt)*) => { syn::Error::new($span, format!($($msg)*)) };
 }
 
-/// Produce a compile error which does not immediately abort.
-macro_rules! error {
-    ($($msg:tt)*) => {{ crate::add_error(format_err!($($msg)*)); }}
-}
-
 /// Our `bail` macro replacement to enforce the inclusion of a `Span`.
 /// The arrow variant takes a spanned syntax element, the comma variant expects an actual `Span` as
 /// first parameter.
@@ -37,7 +30,7 @@ mod util;
 
 /// Handle errors by appending a `compile_error!()` macro invocation to the original token stream.
 fn handle_error(mut item: TokenStream, data: Result<TokenStream, Error>) -> TokenStream {
-    let mut data = match data {
+    match data {
         Ok(output) => output,
         Err(err) => match err.downcast::<syn::Error>() {
             Ok(err) => {
@@ -46,15 +39,12 @@ fn handle_error(mut item: TokenStream, data: Result<TokenStream, Error>) -> Toke
             }
             Err(err) => panic!("error in api/router macro: {}", err),
         },
-    };
-    data.extend(take_non_fatal_errors());
-    data
+    }
 }
 
 /// TODO!
 #[proc_macro]
 pub fn router(item: TokenStream_1) -> TokenStream_1 {
-    let _error_guard = init_local_error();
     let item: TokenStream = item.into();
     handle_error(item.clone(), router_do(item)).into()
 }
@@ -231,48 +221,6 @@ fn router_do(item: TokenStream) -> Result<TokenStream, Error> {
 */
 #[proc_macro_attribute]
 pub fn api(attr: TokenStream_1, item: TokenStream_1) -> TokenStream_1 {
-    let _error_guard = init_local_error();
     let item: TokenStream = item.into();
     handle_error(item.clone(), api::api(attr.into(), item)).into()
 }
-
-thread_local!(static NON_FATAL_ERRORS: RefCell<Option<TokenStream>> = RefCell::new(None));
-
-/// The local error TLS must be freed at the end of a macro as any leftover `TokenStream` (even an
-/// empty one) will just panic between different runs as the multiple source files are handled by
-/// the same compiler thread.
-struct LocalErrorGuard;
-
-impl Drop for LocalErrorGuard {
-    fn drop(&mut self) {
-        NON_FATAL_ERRORS.with(|errors| {
-            *errors.borrow_mut() = None;
-        });
-    }
-}
-
-fn init_local_error() -> LocalErrorGuard {
-    NON_FATAL_ERRORS.with(|errors| {
-        *errors.borrow_mut() = Some(TokenStream::new());
-    });
-    LocalErrorGuard
-}
-
-pub(crate) fn add_error(err: syn::Error) {
-    NON_FATAL_ERRORS.with(|errors| {
-        errors
-            .borrow_mut()
-            .as_mut()
-            .expect("missing call to init_local_error")
-            .extend(err.to_compile_error())
-    });
-}
-
-pub(crate) fn take_non_fatal_errors() -> TokenStream {
-    NON_FATAL_ERRORS.with(|errors| {
-        errors
-            .borrow_mut()
-            .take()
-            .expect("missing call to init_local_mut")
-    })
-}
diff --git a/proxmox-api-macro/src/util.rs b/proxmox-api-macro/src/util.rs
index 3cd29a0..d5488de 100644
--- a/proxmox-api-macro/src/util.rs
+++ b/proxmox-api-macro/src/util.rs
@@ -442,15 +442,14 @@ pub fn derive_descriptions(
 
     if let Some(first) = parts.next() {
         if input_schema.description.is_none() {
-            input_schema.description = Maybe::Derived(syn::LitStr::new(first.trim(), doc_span));
+            input_schema.description = Some(syn::LitStr::new(first.trim(), doc_span));
         }
     }
 
     if let Some(second) = parts.next() {
         if let Some(ref mut returns_schema) = returns_schema {
             if returns_schema.description.is_none() {
-                returns_schema.description =
-                    Maybe::Derived(syn::LitStr::new(second.trim(), doc_span));
+                returns_schema.description = Some(syn::LitStr::new(second.trim(), doc_span));
             }
         }
 
@@ -575,51 +574,3 @@ where
     }
     text
 }
-
-/// Helper to distinguish between explicitly set or derived data.
-#[derive(Clone, Copy, Eq, PartialEq)]
-pub enum Maybe<T> {
-    Explicit(T),
-    Derived(T),
-    None,
-}
-
-impl<T> Maybe<T> {
-    pub fn as_ref(&self) -> Maybe<&T> {
-        match self {
-            Maybe::Explicit(t) => Maybe::Explicit(t),
-            Maybe::Derived(t) => Maybe::Derived(t),
-            Maybe::None => Maybe::None,
-        }
-    }
-
-    pub fn explicit(t: Option<T>) -> Self {
-        match t {
-            Some(t) => Maybe::Explicit(t),
-            None => Maybe::None,
-        }
-    }
-
-    pub fn ok_or_else<E, F>(self, other: F) -> Result<T, E>
-    where
-        F: FnOnce() -> E,
-    {
-        match self {
-            Maybe::Explicit(t) | Maybe::Derived(t) => Ok(t),
-            Maybe::None => Err(other()),
-        }
-    }
-
-    pub fn is_none(&self) -> bool {
-        matches!(self, Maybe::None)
-    }
-}
-
-impl<T> Into<Option<T>> for Maybe<T> {
-    fn into(self) -> Option<T> {
-        match self {
-            Maybe::Explicit(t) | Maybe::Derived(t) => Some(t),
-            Maybe::None => None,
-        }
-    }
-}
diff --git a/proxmox-api-macro/src/api/enums.rs b/proxmox-api-macro/src/api/enums.rs
index f6cc4db..9322f01 100644
--- a/proxmox-api-macro/src/api/enums.rs
+++ b/proxmox-api-macro/src/api/enums.rs
@@ -21,8 +21,8 @@ pub fn handle_enum(
         );
     }
 
-    if let Some(fmt) = attribs.remove("format") {
-        error!(fmt.span(), "illegal key 'format', will be autogenerated");
+    if let Some(fmt) = attribs.get("format") {
+        bail!(fmt.span(), "illegal key 'format', will be autogenerated");
     }
 
     let schema = {
@@ -47,10 +47,9 @@ pub fn handle_enum(
             _ => bail!(variant => "api macro does not support enums with fields"),
         }
 
-        let (mut comment, _doc_span) = util::get_doc_comments(&variant.attrs)?;
+        let (comment, _doc_span) = util::get_doc_comments(&variant.attrs)?;
         if comment.is_empty() {
-            error!(&variant => "enum variant needs a description");
-            comment = "<missing description>".to_string();
+            bail!(variant => "enum variant needs a description");
         }
 
         let attrs = serde::SerdeAttrib::try_from(&variant.attrs[..])?;
diff --git a/proxmox-api-macro/src/api/method.rs b/proxmox-api-macro/src/api/method.rs
index 8b8cfab..f3a108c 100644
--- a/proxmox-api-macro/src/api/method.rs
+++ b/proxmox-api-macro/src/api/method.rs
@@ -68,7 +68,7 @@ pub fn handle_method(mut attribs: JSONObject, mut func: syn::ItemFn) -> Result<T
         .unwrap_or(false);
 
     if !attribs.is_empty() {
-        error!(
+        bail!(
             attribs.span(),
             "unexpected api elements: {}",
             util::join_debug(", ", attribs.elements.keys()),
@@ -171,7 +171,7 @@ enum ParameterType<'a> {
     Other(&'a syn::Type, bool, &'a Schema),
 }
 
-fn check_input_type(input: &syn::FnArg) -> Result<(&syn::PatType, &syn::PatIdent), syn::Error> {
+fn check_input_type(input: &syn::FnArg) -> Result<(&syn::PatType, &syn::PatIdent), Error> {
     // `self` types are not supported:
     let pat_type = match input {
         syn::FnArg::Receiver(r) => bail!(r => "methods taking a 'self' are not supported"),
@@ -204,13 +204,7 @@ fn handle_function_signature(
     let mut param_list = Vec::<(FieldName, ParameterType)>::new();
 
     for input in sig.inputs.iter() {
-        let (pat_type, pat) = match check_input_type(input) {
-            Ok(input) => input,
-            Err(err) => {
-                crate::add_error(err);
-                continue;
-            }
-        };
+        let (pat_type, pat) = check_input_type(input)?;
 
         // For any named type which exists on the function signature...
         if let Some((_ident, optional, ref mut schema)) =
@@ -220,10 +214,10 @@ fn handle_function_signature(
             let is_option = util::infer_type(schema, &*pat_type.ty)?;
             let has_default = schema.find_schema_property("default").is_some();
             if !is_option && *optional && !has_default {
-                error!(pat_type => "optional types need a default or be an Option<T>");
+                bail!(pat_type => "optional types need a default or be an Option<T>");
             }
             if has_default && !*optional {
-                error!(pat_type => "non-optional parameter cannot have a default");
+                bail!(pat_type => "non-optional parameter cannot have a default");
             }
         } else {
             continue;
@@ -231,10 +225,7 @@ fn handle_function_signature(
     }
 
     for input in sig.inputs.iter() {
-        let (pat_type, pat) = match check_input_type(input) {
-            Ok(input) => input,
-            Err(_err) => continue, // we already produced errors above,
-        };
+        let (pat_type, pat) = check_input_type(input)?;
 
         // Here's the deal: we need to distinguish between parameters we need to extract before
         // calling the function, a general "Value" parameter covering all the remaining json
@@ -274,28 +265,24 @@ fn handle_function_signature(
             ParameterType::Other(&pat_type.ty, *optional, schema)
         } else if is_api_method_type(&pat_type.ty) {
             if api_method_param.is_some() {
-                error!(pat_type => "multiple ApiMethod parameters found");
-                continue;
+                bail!(pat_type => "multiple ApiMethod parameters found");
             }
             api_method_param = Some(param_list.len());
             ParameterType::ApiMethod
         } else if is_rpc_env_type(&pat_type.ty) {
             if rpc_env_param.is_some() {
-                error!(pat_type => "multiple RpcEnvironment parameters found");
-                continue;
+                bail!(pat_type => "multiple RpcEnvironment parameters found");
             }
             rpc_env_param = Some(param_list.len());
             ParameterType::RpcEnv
         } else if is_value_type(&pat_type.ty) {
             if value_param.is_some() {
-                error!(pat_type => "multiple additional Value parameters found");
-                continue;
+                bail!(pat_type => "multiple additional Value parameters found");
             }
             value_param = Some(param_list.len());
             ParameterType::Value
         } else {
-            error!(&pat_ident => "unexpected parameter {:?}", pat_ident.to_string());
-            continue;
+            bail!(&pat_ident => "unexpected parameter {:?}", pat_ident.to_string());
         };
 
         param_list.push((param_name, param_type));
@@ -450,13 +437,7 @@ fn create_wrapper_function(
                         });
                     }
                 } else if optional && no_option_type {
-                    // FIXME: we should not be able to reach this without having produced another
-                    // error above already anyway?
-                    error!(ty => "Optional parameter without Option<T> requires a default");
-                    // we produced an error so just write something that will compile
-                    body.extend(quote_spanned! { span =>
-                        .unwrap_or_else(|| unreachable!())
-                    });
+                    bail!(ty => "Optional parameter without Option<T> requires a default");
                 }
                 body.extend(quote_spanned! { span => ; });
                 args.extend(quote_spanned! { span => #arg_name, });
diff --git a/proxmox-api-macro/src/api/structs.rs b/proxmox-api-macro/src/api/structs.rs
index 887ffaa..72843a1 100644
--- a/proxmox-api-macro/src/api/structs.rs
+++ b/proxmox-api-macro/src/api/structs.rs
@@ -135,7 +135,7 @@ fn handle_regular_struct(attribs: JSONObject, stru: syn::ItemStruct) -> Result<T
             schema_fields.insert(field.0.as_str().to_string(), field);
         }
     } else {
-        error!(schema.span, "structs need an object schema");
+        bail!(schema.span, "structs need an object schema");
     }
 
     let mut new_fields: Vec<(FieldName, bool, Schema)> = Vec::new();
@@ -182,7 +182,7 @@ fn handle_regular_struct(attribs: JSONObject, stru: syn::ItemStruct) -> Result<T
     // now error out about all the fields not found in the struct:
     if !schema_fields.is_empty() {
         let bad_fields = util::join(", ", schema_fields.keys());
-        error!(
+        bail!(
             schema.span,
             "struct does not contain the following fields: {}",
             bad_fields
@@ -220,7 +220,7 @@ fn handle_regular_field(
         if derived {
             field_def.1 = true;
         } else if !field_def.1 {
-            error!(&field.ty => "non-optional Option type?");
+            bail!(&field.ty => "non-optional Option type?");
         }
     }
 
diff --git a/proxmox-api-macro/src/serde.rs b/proxmox-api-macro/src/serde.rs
index a08f461..dbfaefe 100644
--- a/proxmox-api-macro/src/serde.rs
+++ b/proxmox-api-macro/src/serde.rs
@@ -143,7 +143,7 @@ impl TryFrom<&[syn::Attribute]> for ContainerAttrib {
                     if var.path.is_ident("rename_all") {
                         let rename_all = RenameAll::try_from(&var.lit)?;
                         if this.rename_all.is_some() && this.rename_all != Some(rename_all) {
-                            error!(var.lit => "multiple conflicting 'rename_all' attributes");
+                            bail!(var.lit => "multiple conflicting 'rename_all' attributes");
                         }
                         this.rename_all = Some(rename_all);
                     }
@@ -180,11 +180,11 @@ impl TryFrom<&[syn::Attribute]> for SerdeAttrib {
                             syn::Lit::Str(lit) => {
                                 let rename = FieldName::from(&lit);
                                 if this.rename.is_some() && this.rename.as_ref() != Some(&rename) {
-                                    error!(lit => "multiple conflicting 'rename' attributes");
+                                    bail!(lit => "multiple conflicting 'rename' attributes");
                                 }
                                 this.rename = Some(rename);
                             }
-                            _ => error!(var.lit => "'rename' value must be a string literal"),
+                            _ => bail!(var.lit => "'rename' value must be a string literal"),
                         }
                     }
                 }
-- 
2.20.1

